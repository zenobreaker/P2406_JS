# P2406_JS
 
[![Video Label](https://img.youtube.com/vi/OlcyzOfpHmI/0.jpg)](https://youtu.be/OlcyzOfpHmI)
<br>사진을 누르면 해당 영상을 확인하실 수 있습니다. </br>

# 📌 프로젝트 개요

| 항목 | 내용 |
| --- | --- |
| 프로젝트명 | TPS Action RPG  |
| 장르 | 3인칭 Action |
| 플랫폼 | PC |
| 개발 기간 | 2024.11 ~ 2025.05 |
| 개발 인원 | 1명 (개인 프로젝트) |
| 엔진 | Unreal 5.3|

<br></br>
[관련 노션 페이지](https://www.notion.so/Unreal-Portfolio-af4349a7aea4402baaf65b902373ed46)


# 🧩 주요 시스템 및 기능

---

## 🔹 Skill System

### 🌀 스킬 시스템 기능 분할 설계

### 🔍 문제 배경

처음에 구현 당시 모든 스킬 로직이 하나의 스크립트에 몰려 있었으며 다음과 같은 문제점이 나타났다.

- 하나의 클래스 안에 스킬 수행, 충돌 처리, 이펙트, 데미지 계산 등의 기능들이 몰리면서 복잡도가 증가
- 스킬마다 요구하는 타격 방식, 이펙트,  동작 조건이 달라 중복 구현이 빈번
- 기능 수정이 어렵고, 테스트 단계에서의 오류 추적도 비효율적이었음

이러한 문제는 스킬은 단일 개체가 아닌 복합적인 행위 체계라는 인식 부족했던 설계 구조 때문

### 🎯 기획 의도 및 고민 방향

> 스킬은 단일 기능이 아닌 의도 → 생성 → 충돌 → 효과라는 과정의 흐름

스킬 로직을 스킬 수행 주체(Active), 월드 상의 실체(Entity), 충돌 처리(Collision) 으로 나눠 역할 분리 원칙(Single Responsibility Principle)을 강화한 시스템을 설계

### 🧩 해결 방안 및 구현 내용

| 구성 요소 | 역할 | 설명 |
| --- | --- | --- |
| **Active Skill** | 스킬 전체 수행 로직 담당 | - **상태 패턴 기반** Flow 설계- 차징, 시전, 쿨다운 등 상태 정의- 각 상태별 이벤트를 독립적으로 작성 가능 |
| **Skill Entity** | 월드 내에 생성되는 스킬 실체 | - 실제 월드에 배치되는 Actor- 위치, 이펙트, 타이머 등의 설정 포함- 충돌체(Skill Collision) 포함 |
| **Skill Collision** | 충돌 판정 및 데미지 처리 | - 단일 타격 / 연속 타격 여부 설정 가능- 콜리전 범위, 팀 판정, 이펙트 트리거 처리 |

![스킬 클래스 구조도](attachment:fcd7f266-381e-4c3f-a0ca-121c001faf39:image.png)

스킬 클래스 구조도

![스킬 시퀀스 ](attachment:ea1cffc0-d580-422e-9afd-98727275a39f:image.png)

스킬 시퀀스 

### 👁️‍🗨️ 결과 및  효과

- 스킬 수행, 실체, 충돌 처리를 명확하게 분할해 **커스터마이징은 조합으로 해결**할 수 있게 함
- 새로운 스킬을 만들 때 기존 구성요소를 조립해 재사용 가능- 디버깅 시 각 책임 단위만 확인하면 되므로 유지보수성 향상- 충돌이나 효과 수정 시 독립적인 변경이 가능함

### 📎 관련 링크

Github: 

[관련 Github1](https://github.com/zenobreaker/P2406_JS/commit/3d306a1ab8ff1c1ea858caed218f2413516627fd)

[관련 Github2](https://github.com/zenobreaker/P2406_JS/commit/0c02436cb330f87086f312cdb6dad02fd6804db0)

[관련 Github2](https://github.com/zenobreaker/P2406_JS/commit/7154903bcf170ae0ef21e4eccd17e45de0629dbc)

---

## 🔹 커스텀 에디터 - Skill Data Asset

### 🌀 스킬 커스텀 에디터 제작

### 🔍 문제 배경

기존의 스킬 편집 환경은 정적인 에디터 필드 구성으로 인해, 사용자가 수정이 불필요한 값까지 건들일 수 있는 구조였다. 

예를 들어 `Phase Type` 이 특정 값(Max 등) 일 때에는 다른 프로퍼티를 수정할 필요가 없음에도 불구하고 여전히 수정 UI가 노출되어 혼란을 유발했다.

또한, 스킬마다 충돌 판정이 필요/불필요한 경우가 있었지만, 일관된 구조 없이 모든 스킬에 동일한 필드가 노출되어 편집자는 매번 불필요한 값을 인지하고 제외해야 하는 부담이 있었다. 

### 🎯 기획 의도 및 고민 방향

- 스킬마다 필요한 편집 필드를 유연하게 제어할 수는 없는가?
- 불필요한 값을 보여주지 않으면 실수도 줄고 집중도 높아지지 않을까?
- 수정 편의성 고려 - 썸네일, 접근 경로 등등.

### 🧩 해결 방안 및 구현 내용

1. 스킬 구성의 3요소에 대한 동적 편집 구조화 
    - 스킬 정보, 상태 흐름(Active), 실체(Entity), 충돌(Collision)를 분리해서 편집
2. 상태 조건에 따른 프로퍼티 노출제어 
    - `PhaseType == Max` 같은 조건의 경우, 해당 상태에서는 다른 프로퍼티는 비활성화 혹은 미노출 처리
        
        → 유효하지 않은 조합 방지, 실수 감소
        
3. 사용자 개선 요소
    - 스킬 정보 수정 시, 썸네일 이미지도 반영
    - 스킬 편집 접근 경로를 툴바/메뉴 등으로 확장

관련 페이지 링크 : [스킬 기능 수정(코드 첨부)](https://www.notion.so/1931775bd70a80598e72f81d0e06b644?pvs=21)  

![프로퍼티 미노출 상태와 노출 상태 ](attachment:e607977a-34b9-43b6-8791-6f84df9dda9a:image.png)

프로퍼티 미노출 상태와 노출 상태 

### 👁️‍🗨️ 결과 및 효과

- 편집자의 혼동과 실수 가능성 대폭 감소
- 필요한 정보만 노출되어 작업 집중도 향상
- 스킬 구조의 일관성과 유연성 동시에 확보
- 편집 기능의 접근성과 시각화 요소 개선으로 작업 효율 상승

### 📎 관련 링크

Github: 

[관련 Github](https://github.com/zenobreaker/P2406_JS/commit/15cc2d296bae2c759c829b755c5506f63f7f3ca6)

---

## 🔹 GameManager

### 🌀 Game Flow Management 설계

### 🔍 문제 배경

게임 시스템이 확장되면서, 게임 흐름을 제어하는 로직이 하나의 클래스에 집중되는 문제가 발생했다.

예를 들어, 게임의 시작/종료, 스테이지 전환, 버프 선택, 적 스폰 등 다양한 기능이 하나의 `GameManager`클래스에 뭉쳐 있던 구조에서는 다음과 같은 문제가 드러났다.

- 클래스가 비대해 지며 단일 책임 원칙이 무너짐
- 서로 다른 역할의 로직이 섞이면서 가독성과 유지보수가 저하됨
- 특정 기능 수정 시, 다른 기능에 영향이 갈 가능성 증가

### 🎯 기획 의도 및 고민 방향

- 게임의 흐름을 담당하는 구조를 어떻게 쪼갤 것인가?
- 각 역할을 독립된 모듈로 나누면서, 상태 변경은 자연스럽게 전달되도록 만들 순 없는가?
- 각 기능을 독립시키되, 전체 흐름은 유기적으로 유지하려면 어떤 패턴을 사용해야 하는가?

### 🧩 해결 방안 및 구현 내용

1. 역할 기반 Manager 클래스 분리
    
    각 기능별 책임을 갖는 매니저 클래스를 설계하고, `GameManager`는 이를 중재한다.
    
    - `GameManager`
        - 게임의 전체 흐름을 관리하는 중앙 조율자
        - 각 상태(에: 버프 선택, 스테이지 시작)에 따라 다른 Manager 호출
    - `BuffManager`
        - 게임 시작 시, 플레이어가 선택할 3가지 버프 정의 및 전달
    - `StageMaanger`
        - 현재 스테이지 정보를 관리, 클리어 여부 및 다음 스테이지 전환 제어
    - `SpawnManager`
        - 적 등장 타이밍 과 패턴 제어, 난이도 조정 등 담당
2. Observer 패턴 기반 이벤트 전달
    - 상태 변화나 게임 이벤트 발생 시, 관심있는 Manager들에게 알림 전달
    - 매니저 간 직접 참조 없이 낮은 결합도 유지

### 👁️‍🗨️ 결과 및 효과

1. 명확한 책임 분리
    - 각 매니저는 한 가지 역할만 수행, 로직의 명확성과 가독성 상승
2. 복잡도 감소 및 유지보수성 향상
    - 특정 기능을 수정할 경우, 해당 매니저만 집중적으로 관리
3. 결합도 최소화
    - 매니저 간의 의존성이 낮아져, 모듈 간 충돌 가능성 감소
4. 확장성 강화
    - 새 기능 추가 시에도 기존 시스템에 부담 없이 삽입 가능

![Manager 클래스 다이어 그램](attachment:519ded0c-1cc4-437a-9f12-06dad91d4b6f:image.png)

Manager 클래스 다이어 그램

### 📎 관련 링크

Github:

[관련 Github](https://github.com/zenobreaker/P2406_JS/commit/ff72e14b4524c46975c274e500bff574c1ac66cc)

---

## 🔹 BuffManager

### 🌀 Buff System 설계

### 🔍 문제 배경

게임 시작 직후, 플레이어에게 랜덤한 버프를 제공해 게임에 다양성과 예측 불가능성을 부여하고자 했다. 

하지만 초기 구현에서는 랜덤으로 출력되는 버프가 중복되어 등장하는 문제가 발생했다. 

또한, 버프를 누가, 어떻게 적용할지에 대한 역할 관리 주체가 명확하지 않은 문제도 있었다.

### 🎯 기획 의도 및 고민 방향

- 버프 적용 후 주체와 버프 관리를 명확히 분리해서 유지보수를 쉽게 하려면 어떻게 하는가?
- 버프 데이터 관리와 UI 표시도 각각 독립적으로 관리하면 편하지 않은가?

### 🧩 해결 방안 및 구현 내용

1. 기능 분리에 따른 역할 정의 
    - BuffManager
        - 버프 목록 관리 및 버프 선택 로직 담당
    - UIManager
        - 버프 UI 출력 및 플레이어 인터랙션 담당
    - Buff 적용 Component
        - 실제 버프 효과를 적용할 대상자에게 붙여 사용
2. 중복 없는 랜덤 선택 -  피셔-에이츠 셔플 적용
    - 피셔-에이츠 알고리즘으로 버프 리스트를 섞어, 동일한 버프가 중복 출력되는 현상 제거
3. 데이터 관리 
    - 버프 관련 데이터는 Data Table에 저장
    - 런타임 시 Data Table에서 데이터를 읽어 처리하도록 구현

### 👁️‍🗨️ 결과 및 효과

- 플레이어는 게임 시작 시 항상 중복 없는 다양한 버프를 경험
- 버프 적용 대상과 관리, UI가 명확히 분리되어 유지보수 편리성 증대
- 데이터 관리를 표준화하여 확장과 수정 용이성 확장

### 📎 관련 링크

Github:

[관련 Github](https://github.com/zenobreaker/P2406_JS/commit/3201b06aa1a51067f55ee8b207a4a5d4652f5304)

---

## 🔹 AI System

### 🌀 AI-Pattern 설계

### 🔍 문제 배경

AI의 다양한 기믹을 추가하기 위해 Phase 개념을 도입하려 했다. 그러나 Phase를 도입했을 때의 자연스러운 Phase 전환 기능의 설계가 부족하여 유연성이 부족했다.

초기 Pattern을 수행하는 기능은 내부에서 결정하므로 편집 단계에서 디버깅하기 어려운 문제가 발생했다. 

### 🎯 기획 의도 및 고민 방향

- AI의 Phase 상태를 유연하게 관리할 수 있는 방법
- 복잡한 Pattern 로직을 더 명확하게 디버깅할 수 있는 구조는 어떻게 만들 수 있는가?

### 🧩 해결 방안 및 구현 내용

1. Blackborad 도입 
    - AI Phase 관리를 Blackboard에 저장하여 중앙 집중적으로 관리
    - Phase 상태의 추적과 변경이 더 쉽고 유연해짐
2. Behavior Tree 기반 설계
    - 기존 하나의 TaskNode 로직을 여러 구조로 분할
    - 외부에서 각 노드의 상태를 확인하여 시각적으로 흐름을 파악하고, 단계별 동작 제어가 명확해짐

### 👁️‍🗨️ 결과 및 효과

- 유연한 관리로 다양한 Pattern 확장 가능
- 여러 TaskNode로 분할함으로써 흐름을 직관적으로 파악, 수정 가능
- 외부화된 로직으로 코드 복잡도 감소 및 문제 발생 시 빠른 원인 파악 가능

![로직 분할 전과 후
](attachment:cad4652f-f89c-4d2d-bf55-67b75c89510e:image.png)

로직 분할 전과 후

### 📎 관련 링크

Github:

[관련 Github1](https://github.com/zenobreaker/P2406_JS/commit/af6336e4e8b7663912338e109ec9760b12b2ebe4)

[관련 Github2](https://github.com/zenobreaker/P2406_JS/commit/15cc2d296bae2c759c829b755c5506f63f7f3ca6)

Notion: 

[AI - Boss 페이즈 변경 개막 패턴 ](https://www.notion.so/AI-Boss-1bb1775bd70a80f2ac8afdf86ba0f115?pvs=21) 

[AI - 회전 처리 ](https://www.notion.so/AI-1bb1775bd70a8061b42fdcbc1d7b11f6?pvs=21) 

[AI - 보스 ai 구성 시 유의 사항](https://www.notion.so/AI-ai-1a61775bd70a80698768f37818c10c59?pvs=21) 

[AI - 보스 ai 해야할 것 정리](https://www.notion.so/AI-ai-1b11775bd70a802290a8f5448cba5f20?pvs=21) 

[AI - 단체 처리](https://www.notion.so/AI-1761775bd70a806da6fee3afd8208190?pvs=21) 

[AI 모델 오류 처리(코드 첨부)](https://www.notion.so/AI-15b1775bd70a8035b9e0e04cc443b7ed?pvs=21) 

---

### 🌀 AI - Battle Management설계

### 🔍 문제 배경

무쌍류처럼 특정 영역에서 다수의 AI 적들이 플레이어를 감지하면 즉시 몰려들고, 전투 중에는 AI 간의 역할 분담과 공격 조율이 필요했다. 

하지만, 기존에는

- 다수 AI 공격자를 효과적으로 제어하고 제한하는 구조 부재
- 전투 발생 시 주변 AI 자연스럽게 참여하지 못함
- 특정 AI만 공격하거나 행동하는 문제

### 🎯 기획 의도 및 고민 방향

- 많은 AI가 무작정 몰려들어 부자연스러운 전투가 되는데, 어떻게 제한할 것인가?
- 전투 상황에서 AI 간 조율을 통해 자연스로운 협동을 어떻게 만들 것인가?
- 플레이어와 AI 간의 관리는 어떻게 할 것인가?

### 🧩 해결 방안 및 구현 내용

1. AI/Target 기반 Battle Manager 설계
    - 공격 가능한 AI 수를 Token 기법으로 제한하여 과도한 공격 방지
    - Token을 가진 AI만 공격 가능하며, 역할 분담 명확
2. Group 시스템 도입 
    - AI 생성 시 그룹에 배치하여 그룹 단위 행동 유도
    - 전투 발생 시 그룹 밖 AI도 적절히 소환하여 전투 자연스러움 강화
3. 중재자 역할 강화
    - Battle Manager가 AI들의 공격 판단 및 조율 담당
    - AI 간 충돌이나 역할 중복 방지, 유지보수성 개선

### 👁️‍🗨️ 결과 및 효과

- AI 공격자 수를 제한 해 성능 저하 방지 및 전투 혼란 감소
- 그룹 단위 AI 행동 조율로 자연스럽고 다이나믹한 전투 연출 가능
- 유지보수가 편리한 구조로, AI 추가 및 조정 시 부담 감소

![BattleManager 시퀀스](attachment:75c6145a-9fc6-4f8e-958a-d6287744273a:image.png)

BattleManager 시퀀스

### 📎 관련 링크

Github:

[관련 Github1](https://github.com/zenobreaker/P2406_JS/commit/f6e3853f955dc439b4ee67eac33a640a6e7de635)

[관련 Github2][https://github.com/zenobreaker/P2406_JS/commit/f3a5d806b1587e73856cf01d5b7c6534180de3de]

---

## 🔹 Attack Judgement System

### 🌀 공격 판정 정확도 개선 : Trace  보강 설계

### 🔍 문제 배경

기존 근접 공격 구현에서는

- 공격 애니메이션이 빠르게 진행되면서 프레인 간격 사이에 타겟이 빠지는 현상이 발생
- 콜리전 기준으로 하는 판정은 공중에 있는 대상을 타격시키기 어려움 발생

애니메이션과 충돌 판정 간의 동기화 미흡이 문제의 핵심이었다. 

### 🎯 기획 의도 및 고민 방향

- 단순히 콜리전만으로는 궤적을 정확히 추적하기 힘들다
- 공중에 있는 적을 위한 별도의 판정이 필요한가?
- 프레임 의존적인 구조를 벗어나기 위한 방법은 무엇인가?

### 🧩 해결 방안 및 구현 내용

1. Attack Trace Component 구현
    - 일정 주기로 Trace를 출력 → 프레임 간 누락 보완
    - 충돌체가 아닌 궤적 중심으로 판정 수행 → 정밀도 향상
2. 공중 적 대응용 별도 Trace 구현
    - 공중에만 반응하는 Trace 추가로 상태 기반 타격 가능
    - 공중 콤보 시 더 넓은 판정 범위적용 → 타격감 및 연출 향상
3. 기존 컴포넌트 의존성 제거
    - Animation Notify나 Frame Time에 의존하지 않도록 설계
    - 언제든지 명확한 타격 판정 가능 → 유지보수 및 기능 확장에 유리

### 👁️‍🗨️ 결과 및 효과

- 프레임 누락없이 타격 판정 수행 가능
- 공중 적/콤보 전용 판정 분리로 유연성 향상
- 정밀도 개선 → 전투의 타격감 및 몰입감 강화
- 컴포넌트화로 기능 재사용성, 구조 명확성 확보

### 📎 관련 링크

Github:

https://github.com/zenobreaker/P2406_JS/commit/b5c53dd1a84bc6a12766dbd672fbbb8e38c55c4e

---

## 🔹 State Effect Management

### 🌀 상태이상 시스템 개선 : 비트마스킹 & 인터페이스 위임

### 🔍 문제 배경

기존 상태이상 처리 방식(상태 패턴 기반)에서는

- 상태 종류가 많아질수록 클래스가 급증한다
- 여러 상태이상이 동시에 적용되는 상황(예: 중독 + 기절)에서 중첩 처리의 유연성 부족
- 각 상태이상이 개별 클래스로 분리되며 관리 포인트가 과도하게 증가

### 🎯 기획 의도 및 고민 방향

- 다양한 상태를 조잡해도 코드가 복잡하지 않아야 한다
- 각 상태에 대한 반응은 개별 로직으로 관리되길 원했다
- 유연성 + 확장성 + 유지보수성을 동시에 확보할 수 있는 구조가 필요했다

### 🧩 해결 방안 및 구현 내용

1. 비트마스킹을 통한 다중 상태 처리 
    - 각 상태이상을 2진수 플래그로 정의
    - AND / OR 연산을 통해 복수 상태 동시 처리 가능
2. 상태 반응 인터페이스 설계
    - 상태별 반응을 담당하는 인터페이스 정의
    - 실질적인 반응은 인터페이스 구현체에서 수행
    - 상태 적용 주체는 상태값 변경과 인터페이스 호출만 담당

### 📎 관련 링크

Github

[관련 Github](https://github.com/zenobreaker/P2406_JS/commit/5bedc475149b201f5e577b588a8b0eb0e9300ece)
