#include "BehaviorTree/BTS/CBTService_MeleeCheck.h"
#include "Global.h"

#include "Characters/CAIController.h"
#include "Characters/CEnemy_AI.h"

#include "Components/CStateComponent.h"
#include "Components/CAIBehaviorComponent.h"

UCBTService_MeleeCheck::UCBTService_MeleeCheck()
{
	NodeName = "MeleeCheck";
}

void UCBTService_MeleeCheck::OnSearchStart(FBehaviorTreeSearchData& SearchData)
{
	CachedController = Cast<ACAIController>(SearchData.OwnerComp.GetOwner());
	CheckNull(CachedController);

	CachedAI = Cast<ACEnemy_AI>(CachedController->GetPawn());
	CheckNull(CachedAI);

	CachedBehavior = FHelpers::GetComponent<UCAIBehaviorComponent>(CachedAI);
	CachedState = FHelpers::GetComponent<UCStateComponent>(CachedAI);
}

void UCBTService_MeleeCheck::TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)
{
	Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);

	CheckNull(CachedBehavior); 
	CheckTrue(CachedBehavior->IsApproachMode());
	CheckTrue(CachedBehavior->IsDeadMode());

	// 공격할 대상을 찾는다. 
	ACharacter* target = nullptr; 
	target = CachedBehavior->GetTarget(); 
	CheckNull(target);
	
	FVector targetPosition = target->GetActorLocation();
	// 타겟이 있으면 타겟 주변에 다른 팀원들 검사 
	TArray<FOverlapResult> results; 

	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(CachedAI);
	QueryParams.AddIgnoredActor(target);

	bool bOverlapped = GetWorld()->OverlapMultiByChannel(
		results,
		targetPosition,
		FQuat::Identity,
		ECC_Pawn,
		FCollisionShape::MakeSphere(DetectionRadius),
		QueryParams
	);

	CheckFalse(bOverlapped);

	int32 myTeam_id = CachedAI->GetTeamID();
	for (const FOverlapResult& result : results)
	{
		ACEnemy_AI* other_Ai = Cast<ACEnemy_AI>(result.GetActor());
		if (other_Ai == nullptr)
			continue; 
		// 다른 팀인지 구분 
		int32 other_id = other_Ai->GetTeamID();
		// 다른 팀은 생각안 함
		if (other_id != myTeam_id)
			continue; 

		UCStateComponent* state = FHelpers::GetComponent<UCStateComponent>(other_Ai);
		if (state == nullptr)
			continue; 

		CheckTrue(Calc_ThinkValue());
		CheckTrue(CachedBehavior->IsActionMode());
		
		
		// 하나라도 공격자가 있으면 자신의 상태는 Wait으로 대기한다. 
		if (state->IsActionMode())
		{
			FLog::Log("who are ? Attack" + other_Ai->GetName());
			CachedBehavior->SetWaitMode();

			return; 
		}
	}

}

bool UCBTService_MeleeCheck::Calc_ThinkValue()
{
	if (ThinkValue.X <= 0.0f)
		return false; 

	//ThinkValue 내에 값이 온다면 공격자가 있어도 공격하게 한다. 
	float randValue = FMath::RandRange(0.0f, (float)ThinkValue.Y);

	// 생각한 결과가 조건과 맞아 떨어지면 그대로 수행하게 한다.
	if (randValue <= ThinkValue.X)
	{
		return true;
	}

	return false;
}
